[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 Bristol Vaccine Centre Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rob Challen. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Challen R (2023). pkgutils: Functions building functions. https://bristol-vaccine-centre.github.io/pkgutils/index.html, https://github.com/bristol-vaccine-centre/pkgutils.","code":"@Manual{,   title = {pkgutils: Functions for building functions},   author = {Rob Challen},   year = {2023},   note = {https://bristol-vaccine-centre.github.io/pkgutils/index.html, https://github.com/bristol-vaccine-centre/pkgutils}, }"},{"path":"/index.html","id":"pkgutils","dir":"","previous_headings":"","what":"Functions for building functions","title":"Functions for building functions","text":"Functions writing R functions","code":""},{"path":"/reference/check_consistent.html","id":null,"dir":"Reference","previous_headings":"","what":"Check function parameters are conform to a set of rules — check_consistent","title":"Check function parameters are conform to a set of rules — check_consistent","text":"Check function parameters conform set rules","code":""},{"path":"/reference/check_consistent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check function parameters are conform to a set of rules — check_consistent","text":"","code":"check_consistent(..., .env = rlang::caller_env())"},{"path":"/reference/check_consistent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check function parameters are conform to a set of rules — check_consistent","text":"... set rules check either x=y+z, x>y. Single = assignment checked equality using identical otherwise expressions evaluated checked true. consistency resolve_missing uses assignment, ignores logical expressions. .env environment check ","code":""},{"path":"/reference/check_consistent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check function parameters are conform to a set of rules — check_consistent","text":"nothing, throws informative error checks fail.","code":""},{"path":"/reference/check_consistent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check function parameters are conform to a set of rules — check_consistent","text":"","code":"testfn = function(pos=NULL, neg=NULL, n=NULL) {   check_consistent(pos=n-neg, neg=n-pos, n=pos+neg, n>pos, n>neg) }  testfn(pos = 1:4, neg=4:1, n=rep(5,4)) try(testfn(pos = 1:4, neg=5:2, n=rep(5,4))) #> Error in check_consistent(pos = n - neg, neg = n - pos, n = pos + neg,  :  #>   1) constraint 'pos = n - neg' is not met. #> 2) constraint 'neg = n - pos' is not met. #> 3) constraint 'n = pos + neg' is not met. #> 4) constraint 'n > neg' is not met"},{"path":"/reference/fix_unqualified_fns.html","id":null,"dir":"Reference","previous_headings":"","what":"Fix errors introduced in package creation by forgetting to qualify\nnamespaces. — fix_unqualified_fns","title":"Fix errors introduced in package creation by forgetting to qualify\nnamespaces. — fix_unqualified_fns","text":"code linting function expected called console package development. scan files current project replace unqualified references e.g. mutate ones dplyr::mutate etc.","code":""},{"path":"/reference/fix_unqualified_fns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fix errors introduced in package creation by forgetting to qualify\nnamespaces. — fix_unqualified_fns","text":"","code":"fix_unqualified_fns(   rDirectories = c(here::here(\"R\"), here::here(\"vignettes\"),     here::here(\"tests/testthat\")),   description = here::here(\"DESCRIPTION\"),   dry_run = TRUE )"},{"path":"/reference/fix_unqualified_fns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fix errors introduced in package creation by forgetting to qualify\nnamespaces. — fix_unqualified_fns","text":"rDirectories locations R code fix (default R scripts, vignettes, tests) description location description file dry_run default function actually anything unless set FALSE. However dry run output can manually compared diff tool interactively accept changes.","code":""},{"path":"/reference/fix_unqualified_fns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fix errors introduced in package creation by forgetting to qualify\nnamespaces. — fix_unqualified_fns","text":"nothing. called side effects.","code":""},{"path":"/reference/get_fn_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the name of a function — get_fn_name","title":"Get the name of a function — get_fn_name","text":"Functions may named anonymous. functions used parameter, error reporting sometimes useful able refer function name given defined. Sometimes functions can multiple names.","code":""},{"path":"/reference/get_fn_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the name of a function — get_fn_name","text":"","code":"get_fn_name(fn = rlang::caller_fn(), fmt = \"%s\", collapse = \"/\")"},{"path":"/reference/get_fn_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the name of a function — get_fn_name","text":"fn function definition (defaults function get_fn_name called) fmt passed sprintf function name e.g. %s() append brackets collapse passed paste0 case multiple matching functions. set NULL want multiple function names vector.","code":""},{"path":"/reference/get_fn_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the name of a function — get_fn_name","text":"name function \"<unknown>\" known","code":""},{"path":"/reference/get_fn_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the name of a function — get_fn_name","text":"","code":"# detecting the name when function used as a parameter. This is the  # primary use case for `get_fn_name` testfn2 = function(fn) {   message(\"called with function: \",get_fn_name(fn)) }  testfn2(mean) #> called with function: mean testfn2(utils::head) #> called with function: head # this is quite slow for some reason: testfn2(stats::quantile)  # detecting the name of a calling function, an unusual use case as this is # normally known to the user. testfn = function() {   message(get_fn_name(fmt=\"%s(...)\"),\" is a function\") }  `test fn 2` = testfn test_fn_3 = testfn testfn() #> `test fn 2`(...)/test_fn_3(...)/testfn(...) is a function"},{"path":"/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"/reference/recycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Strictly recycle function parameters — recycle","title":"Strictly recycle function parameters — recycle","text":"recycle called within function ensures parameters calling function length repeating using rep. function alters environment called used caution. stricter R recycling repeat vectors length one match longer ones, throws informative errors.","code":""},{"path":"/reference/recycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Strictly recycle function parameters — recycle","text":"","code":"recycle(..., .min = 1)"},{"path":"/reference/recycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Strictly recycle function parameters — recycle","text":"... variables recycle .min minimum length results (defaults 1)","code":""},{"path":"/reference/recycle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Strictly recycle function parameters — recycle","text":"length longest variable","code":""},{"path":"/reference/recycle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Strictly recycle function parameters — recycle","text":"","code":"testfn = function(a, b, c) {   n = recycle(a,b,c)   print(a)   print(b)   print(c)   print(n) }  testfn(a=c(1,2,3), b=\"needs recycling\", c=NULL) #> [1] 1 2 3 #> [1] \"needs recycling\" \"needs recycling\" \"needs recycling\" #> NULL #> [1] 3"},{"path":"/reference/resolve_missing.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve missing values in function parameters — resolve_missing","title":"Resolve missing values in function parameters — resolve_missing","text":"Uses relationships parameters iteratively fill missing values. possible specify inconsistent set rules data case resulting values picked error thrown.","code":""},{"path":"/reference/resolve_missing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve missing values in function parameters — resolve_missing","text":"","code":"resolve_missing(..., .env = rlang::caller_env())"},{"path":"/reference/resolve_missing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve missing values in function parameters — resolve_missing","text":"... set relationships list x=y+z expressions .env environment check (optional - defaults caller_env())","code":""},{"path":"/reference/resolve_missing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve missing values in function parameters — resolve_missing","text":"nothing. Alters .env environment fill missing values throws informative error","code":""},{"path":"/reference/resolve_missing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Resolve missing values in function parameters — resolve_missing","text":"","code":"# missing variables left with default value of NULL in function definition testfn = function(pos = NULL, neg=NULL, n=NULL) {   resolve_missing(pos=n-neg, neg=n-pos, n=pos+neg)   return(tibble::tibble(pos=pos,neg=neg,n=n)) }  testfn(pos=1:4, neg = 4:1) #> # A tibble: 4 × 3 #>     pos   neg     n #>   <int> <int> <int> #> 1     1     4     5 #> 2     2     3     5 #> 3     3     2     5 #> 4     4     1     5 testfn(neg=1:4, n = 10:7) #> # A tibble: 4 × 3 #>     pos   neg     n #>   <int> <int> <int> #> 1     9     1    10 #> 2     7     2     9 #> 3     5     3     8 #> 4     3     4     7  # not enough info to infer the missing variables try(testfn(neg=1:4)) #> Error in resolve_missing(pos = n - neg, neg = n - pos, n = pos + neg) :  #>   unable to infer missing variables: `n`, `pos` using: #> pos = n - neg #> neg = n - pos #> n = pos + neg #> given variables: `neg`  # the parameters given are inconsistent with the relationships defined. try(testfn(pos=2, neg=1, n=4)) #> Error in check_consistent(..., .env = env) :  #>   1) constraint 'pos = n - neg' is not met. #> 2) constraint 'neg = n - pos' is not met. #> 3) constraint 'n = pos + neg' is not met."}]
